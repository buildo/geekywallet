{
  var indentStack = [], indent = "";
  var line = 1;
}

start
  = h:header EOL+ ll:lines {
      return {
        group: {
          context: h,
          lines: ll
        }
      }
    }

header
  = people

people
  = "@people" pl:people_list { return pl; }

people_list
  = pp:(_ p:name {return p;})+ {
    return {people: pp}
  }

name
  = name:[a-zA-Z]+ {
    return name.join("").toLowerCase();
  }

lines
  = ll:line* {
    return ll.filter(function(l) { return l != null });
  }

line
  = SAMEDENT t:transaction EOL* comment? EOL* {
    return t;
  }
  / SAMEDENT block_header EOL INDENT ll:line+ OUTDENT {
    return {block: true, lines: ll}
  }
  / comment EOL* { return null; }

block_header
  = command _? ("," _? command)*

command
  = group_command
  / date_command
  / tag_command
  / currency_command

group_command
  = "@group" pl:people_list

date_command
  = "@date" _ d:date

tag_command
  = "@tag" tl:tag_list

tag_list
  = (_ tag)+

currency_command
  = "@currency" _ n:number

transaction
  = date:(d:date _ {return d;})?
    desc:(d:description ":" _? { return d; })?
    p:payers
    bs:(
      _
      arrow:("->" / "<-")
      bb:(_? b:beneficiaries { return b; })?
      opts:options {
        return [bb, opts, arrow];
      }
    )?
    _?
    c:comment? {
      var o = {
        date : date,
        payers : p,
        options: []
      };
      if (desc) {
        o.desc = desc.desc;
        o.tags = desc.tags;
      }
      if (bs) {
        o.beneficiaries = bs[0];
        o.options = bs[1];
        o.reversed = bs[2] !== "->";
      }
      if (c) {
        o.comment = c;
      }
      return o;
    }

comment
  = "#" _? c:[^\n]* { return c.join("").trim(); }

date
  = year:([0-9][0-9][0-9][0-9]?)"-"month:([0-9][0-9])"-"day:([0-9][0-9]) {
      return new Date(year.join(""), month.join("") - 1, day.join(""));
  }

description
  = w:[^:#]+ {
      var desc = w.join("");
      return {
        desc: desc,
        tags: desc.match(/#[^# ]+/g)
      };
  }

word
  = word:[a-zA-Z-_'0-9"]+ { return word.join(""); }

tag
  = t:("#" word) { return t.join(""); }

payers
  = p:payer others:(_ p_n:payer { return p_n; })* {
      return [p].concat(others);
    }

payer
  = n:name _ e:expr { return {name : n, amount: e}; }

beneficiaries
  = b:beneficiary others:(_ b_n:beneficiary { return b_n; })* {
        return [b].concat(others);
    }
  / "" { return []; }

beneficiary
  = n:name _ m:modifier {
        return {
               name : n,
               modifiers : m
        };
    } /
    n:name _ a:expr {
        return {
               name : n,
               fixedAmount : a,
        };
    } /
    n:name {
        return {
            name : n
        };
    }

modifier
  = o:offset _ m:multiplier { return { offset: o, multiplier: m }; }
  / m:multiplier _ o:offset { return { offset: o, multiplier: m }; }
  / o:offset { return { offset: o }; }
  / m:multiplier { return { multiplier: m }; }

offset
  = "+" a:expr { return a; }
  / "-" a:expr { return -a; }

multiplier
  = "*" a:expr { return a; }

options
  = opts:(_ o:option { return o; })* { return opts; }

option
  = "..." { return { name: "group" }; }
  / "$"+ { return { name: "split" }; }

expr
  = res:sum { return res; }

sum
  = t:term others:(t_n:(("+"/"-") term) { return parseFloat(t_n.join("")); })* {
      var sum = t;
      var length = others.length;
      for (var i = 0; i < length; i++) {
          sum += others[i];
      }
      return sum;
    }



term
  = f:factor others:("*" f_n:factor { return f_n; })* {
        var prod = f;
        var length = others.length;
        if (length > 0) {
            for (var i = 0; i < length; i++) {
                prod *= others[i];
            }
        }
        return prod;
    }

factor
  = number /
          "(" e:expr ")" { return e; }

float
  = n:((integer)? "." integer) { return parseFloat(n.join("")); }

integer
  = n:[0-9]+ { return parseInt(n.join("")); }

number
  = float / integer

_ = whitespace+

whitespace
  = " " / "\t"

EOL
  = "\r\n" / "\n" / "\r" {
    line++;
  }

NOT_EOL
  = EOL &{ return false }
  / . { return true }

SAMEDENT
  = i:[ \t]* &{ return i.join("") === indent; }

INDENT
  = i:[ \t]+ &{ return i.length > indent.length; }
    { indentStack.push(indent); indent = i.join(""); pos = offset; }

OUTDENT
  = { indent = indentStack.pop(); }
